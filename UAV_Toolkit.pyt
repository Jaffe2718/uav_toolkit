# -*- coding: utf-8 -*-import arcpyimport mathimport numpy as npfrom typing import ListGPU_AVAILABLE = FalseGPU_MEMORY = 0try:    import torch    from segment_anything import sam_model_registry, SamAutomaticMaskGenerator    GPU_AVAILABLE = torch.cuda.is_available()    if GPU_AVAILABLE:        GPU_MEMORY = torch.cuda.get_device_properties(0).total_memory / 1024 ** 3except ImportError as ie:    raise ImportError("Dependency import error: \n{}".format(ie))class Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [SegmentAnything]class SegmentAnything(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Segment Anything"        self.description = "Use a Segment Anything Model (SAM) to segment all objects in UAV images in Feature Class format."        self.canRunInBackground = True    def getParameterInfo(self) -> List[arcpy.Parameter]:        """        Define parameter definitions        """        # Input parameters        model_checkpoint_path = arcpy.Parameter(  # model checkpoint file            category="Model Checkpoint Parameters",            displayName="Model Checkpoint Path",            name="model_checkpoint_path",            datatype="DEFile",            parameterType="Required",            direction="Input",        )        # model_checkpoint_path.message = "Select a Segment Anything Model checkpoint file (e.g., sam_vit_h_4b8939.pth)"        model_checkpoint_path.filter.list = ['pth']        model_checkpoint_type = arcpy.Parameter(  # vit_h (default), vit_l, vit_b only, no other models            category="Model Checkpoint Parameters",            displayName="Model Type",            name="model_checkpoint_type",            datatype="GPString",            parameterType="Required",            direction="Input",        )        # model_checkpoint_type.message = "Select a Segment Anything Model type in {vit_h, vit_l, vit_b}"        model_checkpoint_type.filter.type = "ValueList"        model_checkpoint_type.filter.list = ["vit_h", "vit_l", "vit_b"]        model_checkpoint_type.value = "vit_h"  # default value        # Raster parameters        input_raster = arcpy.Parameter(            category="Input Raster",            displayName="Input Raster",            name="input_raster",            datatype="DERasterDataset",            parameterType="Required",            direction="Input",        )        red_channel = arcpy.Parameter(  # get the band from the input raster as the red channel            category="Input Raster",            displayName="Red Channel",            name="red_channel",            datatype="GPString",            parameterType="Required",            direction="Input",        )        red_channel.filter.type = "ValueList"        # TODO: initialize the value list in the updateParameters method        green_channel = arcpy.Parameter(  # get the band from the input raster as the green channel            category="Input Raster",            displayName="Green Channel",            name="green_channel",            datatype="GPString",            parameterType="Required",            direction="Input",        )        green_channel.filter.type = "ValueList"        # TODO: initialize the value list in the updateParameters method        blue_channel = arcpy.Parameter(  # get the band from the input raster as the blue channel            category="Input Raster",            displayName="Blue Channel",            name="blue_channel",            datatype="GPString",            parameterType="Required",            direction="Input",        )        blue_channel.filter.type = "ValueList"        # Segmentation parameters        points_per_side = arcpy.Parameter(  # must > 0            category="Segmentation Parameters",            displayName="Points per Side",            name="points_per_side",            datatype="GPLong",            parameterType="Required",            direction="Input",        )        points_per_side.value = 32  # default value        points_per_side.filter.type = "Range"        points_per_side.filter.list = [1, math.inf]        points_per_batch = arcpy.Parameter(            # number of points per batch for the raster            category="Segmentation Parameters",            displayName="Points per Batch",            name="points_per_batch",            datatype="GPLong",            parameterType="Required",            direction="Input",        )        points_per_batch.value = int(GPU_MEMORY) if GPU_AVAILABLE else 64  # default value        points_per_batch.filter.type = "Range"        points_per_batch.filter.list = [1, math.inf]        pred_iou_thresh = arcpy.Parameter(  # must be in [0, 1]            category="Segmentation Parameters",            displayName="Predicted IoU Threshold",            name="pred_iou_thresh",            datatype="GPDouble",            parameterType="Required",            direction="Input",        )        pred_iou_thresh.value = 0.88  # default value        pred_iou_thresh.filter.type = "Range"        pred_iou_thresh.filter.list = [0, 1]        stability_score_thresh = arcpy.Parameter(  # must be in [0, 1]            category="Segmentation Parameters",            displayName="Stability Score Threshold",            name="stability_score_thresh",            datatype="GPDouble",            parameterType="Required",            direction="Input",        )        stability_score_thresh.value = 0.95  # default value        stability_score_thresh.filter.type = "Range"        stability_score_thresh.filter.list = [0, 1]        stability_score_offset = arcpy.Parameter(  # no limit            category="Segmentation Parameters",            displayName="Stability Score Offset",            name="stability_score_offset",            datatype="GPDouble",            parameterType="Required",            direction="Input",        )        stability_score_offset.value = 1.0  # default value        box_nms_thresh = arcpy.Parameter(  # no limit, all real numbers            category="Segmentation Parameters",            displayName="Box NMS Threshold",            name="box_nms_thresh",            datatype="GPDouble",            parameterType="Required",            direction="Input",        )        box_nms_thresh.value = 0.7  # default value        crop_n_layers = arcpy.Parameter(  # no-negative integer            category="Segmentation Parameters",            displayName="Crop N Layers",            name="crop_n_layers",            datatype="GPLong",            parameterType="Required",            direction="Input",        )        crop_n_layers.value = 0  # default value        crop_n_layers.filter.type = "Range"        crop_n_layers.filter.list = [0, math.inf]        crop_nms_thresh = arcpy.Parameter(  # [0, 1]            category="Segmentation Parameters",            displayName="Crop NMS Threshold",            name="crop_nms_thresh",            datatype="GPDouble",            parameterType="Required",            direction="Input",        )        crop_nms_thresh.value = 0.7  # default value        crop_nms_thresh.filter.type = "Range"        crop_nms_thresh.filter.list = [0, 1]        crop_overlap_ratio = arcpy.Parameter(  # [0, 1]            category="Segmentation Parameters",            displayName="Crop Overlap Ratio",            name="crop_overlap_ratio",            datatype="GPDouble",            parameterType="Required",            direction="Input",        )        crop_overlap_ratio.value = 512 / 1500  # default value        crop_overlap_ratio.filter.type = "Range"        crop_overlap_ratio.filter.list = [0, 1]        crop_n_points_downscale_factor = arcpy.Parameter(  # [1, +inf)            category="Segmentation Parameters",            displayName="Crop N Points Downscale Factor",            name="crop_n_points_downscale_factor",            datatype="GPLong",            parameterType="Required",            direction="Input",        )        crop_n_points_downscale_factor.value = 2  # default value        crop_n_points_downscale_factor.filter.type = "Range"        crop_n_points_downscale_factor.filter.list = [1, math.inf]        min_mask_region_area = arcpy.Parameter(  # [0, +inf), if > 0, openCV is required            category="Segmentation Parameters",            displayName="Minimum Mask Region Area",            name="min_mask_region_area",            datatype="GPLong",            parameterType="Required",            direction="Input",        )        min_mask_region_area.value = 0  # default value        min_mask_region_area.filter.type = "Range"        min_mask_region_area.filter.list = [0, math.inf]        # TODO: Add more parameters for the model        # Export parameters        output_feature_class = arcpy.Parameter(  # output vector file            category="Export Parameters",            displayName="Output Vector",            name="output_feature_class",            datatype="DEFeatureClass",            parameterType="Required",            direction="Output",        )        gpu_acceleration = arcpy.Parameter(  # use GPU if available            displayName="Use GPU Acceleration",            name="use_gpu",            datatype="GPBoolean",            parameterType="Required",            direction="Input",        )        gpu_acceleration.value = GPU_AVAILABLE  # default is True if GPU is available        params = [model_checkpoint_path, model_checkpoint_type,                  input_raster, red_channel, green_channel, blue_channel,                  points_per_side, points_per_batch, pred_iou_thresh, stability_score_thresh, stability_score_offset,                  box_nms_thresh, crop_n_layers, crop_nms_thresh, crop_overlap_ratio, crop_n_points_downscale_factor,                  min_mask_region_area,                  output_feature_class,                  gpu_acceleration]        return params    def isLicensed(self) -> bool:        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters: List[arcpy.Parameter]) -> None:        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        if parameters[2].altered:  # if the input raster is changed            raster = arcpy.Raster(parameters[2].valueAsText)            parameters[3].filter.list = parameters[4].filter.list = parameters[5].filter.list = raster.bandNames            parameters[3].value = raster.bandNames[-1]  # default value            parameters[4].value = raster.bandNames[-2] if len(raster.bandNames) > 1 else raster.bandNames[-1]            parameters[5].value = raster.bandNames[-3] if len(raster.bandNames) > 2 else raster.bandNames[-1]    def updateMessages(self, parameters: List[arcpy.Parameter]) -> None:        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""    def execute(self, parameters: List[arcpy.Parameter], messages) -> None:        """The source code of the tool."""        model_checkpoint_path = parameters[0].valueAsText  # model checkpoint file path        model_checkpoint_type = parameters[1].valueAsText        if model_checkpoint_type not in {"vit_h", "vit_l", "vit_b"}:            raise ValueError("Invalid model type: {}".format(model_checkpoint_type) + "\n" +                             "Valid model types are: vit_h, vit_l, vit_b")        sam = sam_model_registry[model_checkpoint_type](checkpoint=model_checkpoint_path)        if GPU_AVAILABLE and parameters[17].value:  # use GPU if available            sam.to("cuda")        else:            messages.addWarning("CUDA is not available. Using CPU for inference.")        messages.addMessage("Model loaded: {}".format(model_checkpoint_path))        if parameters[16].value > 0:            try:                __import__("cv2")            except ImportError as ie:                raise ImportError("Dependency import error: \n{}".format(ie) + "\n" +                                  "OpenCV is required for post-processing with min_mask_region_area > 0.")        mask_generater = SamAutomaticMaskGenerator(sam,                                                   points_per_side=parameters[6].value,                                                   points_per_batch=parameters[7].value,                                                   pred_iou_thresh=parameters[8].value,                                                   stability_score_thresh=parameters[9].value,                                                   stability_score_offset=parameters[10].value,                                                   box_nms_thresh=parameters[11].value,                                                   crop_n_layers=parameters[12].value,                                                   crop_nms_thresh=parameters[13].value,                                                   crop_overlap_ratio=parameters[14].value,                                                   crop_n_points_downscale_factor=parameters[15].value,                                                   min_mask_region_area=parameters[16].value)        messages.addMessage("Segmentation parameters set.")        # read the raster as a numpy array        ori_raster = arcpy.Raster(parameters[2].valueAsText)  # input original raster        image = self._raster2numpy(ori_raster,                                   parameters[3].value,                                   parameters[4].value,                                   parameters[5].value)        # gen masks, each mask is a 0-1 numpy array, we need to convert it to a polygon into a feature class        masks = mask_generater.generate(image)        messages.addMessage("Masks generated.")        # cache all mask into a matrix with hte shape of the ori        all_masks_matrix = np.zeros(image.shape[:2], dtype=np.uint32)        for i, mask in enumerate(masks):            all_masks_matrix += np.array(mask['segmentation'], dtype=np.uint32) * (i + 1)        # turn the matrix into a raster with the same spatial reference and coordinate system as the input raster        all_masks_raster: arcpy.Raster = arcpy.NumPyArrayToRaster(in_array=all_masks_matrix,                                                                  lower_left_corner=arcpy.Point(                                                                      X=ori_raster.extent.XMin,                                                                      Y=ori_raster.extent.YMin,                                                                      M=ori_raster.extent.MMin),                                                                  x_cell_size=ori_raster.meanCellWidth,                                                                  y_cell_size=ori_raster.meanCellHeight,                                                                  mdinfo=ori_raster.mdinfo)        arcpy.DefineProjection_management(in_dataset=all_masks_raster, coor_system=ori_raster.spatialReference)        messages.addMessage("Masks merged: {}".format(ori_raster.mdinfo))        # create a feature class from the raster        feature_class = arcpy.RasterToPolygon_conversion(in_raster=all_masks_raster,                                                         out_polygon_features=parameters[17].valueAsText)        # add the feature class to the current map        arcpy.SetParameterAsText(17, feature_class)        messages.addMessage("Feature class created.")    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""    def _raster2numpy(self, raster: arcpy.Raster, r_channel: str, g_channel: str, b_channel: str):        """Convert a raster to a numpy array."""        r, g, b = raster.bandNames.index(r_channel), raster.bandNames.index(g_channel), raster.bandNames.index(            b_channel)        mat = arcpy.RasterToNumPyArray(raster, arcpy.Point(raster.extent.XMin, raster.extent.YMin), nodata_to_value=0)        # get only the selected bands        return np.stack((mat[r - 1], mat[g - 1], mat[b - 1]), axis=-1)